{"pageProps":{"postData":{"id":["2024","03","10","rinha-backend-2024-q1"],"contentHtml":"<p>Hoje, dia 10/03/2024, se encerra o prazo para submissão de projetos para a\n<a href=\"https://github.com/zanfranceschi/rinha-de-backend-2024-q1\">Rinha de Backend - 2024/Q1</a>, que é a segunda edição\nda Rinha de Backend. Resumindo, era preciso entregar um projeto que simule um serviço bancário com extrato e criação\nde transações concorrentemente, onde as contas nunca podem ficar com saldo negativo abaixo do limite de cada\ncliente. Além disso, era necessário rodar em docker, com um load balancer distribuindo a carga para no mínimo dois\nserviços de API, sendo que todos os serviços juntos poderiam usar no máximo 1.5 unidades de CPU e 550MB de memória.</p>\n<p>Não participei da <a href=\"https://github.com/zanfranceschi/rinha-de-backend-2023-q3\">primeira edição em 2023</a> pois só fiquei\nsabendo depois de encerrada.</p>\n<p>Após essa primeira edição da Rinha de Backend, houve uma Rinha de Compiladores\n(e interpretadores) onde consegui participar e <a href=\"https://github.com/asfernandes/rinha-de-compiler\">meu projeto</a>\nficou em 9º no <a href=\"https://github.com/aripiprazole/rinha-de-compiler?tab=readme-ov-file#competi%C3%A7%C3%A3o\">ranking</a>.</p>\n<p>Um fato interessante das rinhas é que o critério do ranking final não é muito claro antecipadamente. O objetivo\né se divertir e aprender.</p>\n<p>Voltando a Rinha de Backend 2024/Q1, outro ponto interessante é que para o ranking, os testes são executados\n<a href=\"https://github.com/zanfranceschi/rinha-de-backend-2024-q1/blob/main/SPECTESTENV.md\">nessa máquina</a>. Eu fiz meus testes\nem duas máquinas diferentes, um desktop Ryzen 9 com 24 cores e um notebook Core i7 de 7ª geração com 4 cores. No Ryzen 9\nqualquer coisa rodava muito rápido, mesmo com a limitação de CPU no docker. Algumas técnicas que melhoravam o desempenho\nno desktop, pioravam no notebook. Nesses casos priorizei as técnicas que melhoravam no notebook.</p>\n<p>Submeti 3 projetos construídos com uma mesma stack base:</p>\n<ul>\n<li><code>C++20</code> como linguagem de programação</li>\n<li><code>mongoose</code> como lib http</li>\n<li><code>vcpkg</code> como gerenciador de pacotes</li>\n<li><code>haproxy</code> como load balancer</li>\n</ul>\n<p>Nos projetos usei diferentes bancos de dados e algumas alterações no código:</p>\n<ul>\n<li><a href=\"https://github.com/asfernandes/rinhaback24q1-haproxy-mongoose-pgsql\">rinhaback24q1-haproxy-mongoose-pgsql</a></li>\n<li><a href=\"https://github.com/asfernandes/rinhaback24q1-haproxy-mongoose-firebird\">rinhaback24q1-haproxy-mongoose-firebird</a></li>\n<li><a href=\"https://github.com/asfernandes/rinhaback24q1-haproxy-mongoose-lmdb\">rinhaback24q1-haproxy-mongoose-lmdb</a></li>\n</ul>\n<h1>PostgreSQL</h1>\n<p>A grande maioria dos (até então) 677 projetos usou o PostgreSQL como banco de dados. Resolvei fazer uma versão com ele\ne no ranking provisório esse projeto ficou com um <strong>p75 de 1ms</strong>.</p>\n<p>Ficou um projeto com um modelo de dados bastante tradicional:</p>\n<div class=\"remark-highlight\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">create</span> unlogged <span class=\"token keyword\">table</span> account <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">integer</span> <span class=\"token keyword\">primary</span> <span class=\"token keyword\">key</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    balance <span class=\"token keyword\">integer</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    overdraft <span class=\"token keyword\">integer</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">create</span> unlogged <span class=\"token keyword\">table</span> <span class=\"token keyword\">transaction</span> <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">serial</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    account_id <span class=\"token keyword\">integer</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    val <span class=\"token keyword\">integer</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    description <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">datetime</span> <span class=\"token keyword\">timestamp</span> <span class=\"token keyword\">with</span> <span class=\"token keyword\">time</span> zone <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">index</span> idx_transaction_account_id_id_desc <span class=\"token keyword\">on</span> <span class=\"token keyword\">transaction</span> <span class=\"token punctuation\">(</span>\n    account_id<span class=\"token punctuation\">,</span>\n    id <span class=\"token keyword\">desc</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>Usei 0,5 CPU e 390MB para o container do PostgreSQL, 0,2 CPU e 50MB para cada um dos dois containers de API e\n0,6 CPU e 60MB para o haproxy.</p>\n<p>Em cada instância da API usei um thread pool de 8 workers HTTP e um connection pool de 8 conexões para o banco de\ndados. Cada request que chega pela mongoose é enviado para o thread pool e respondido de forma assíncrona.</p>\n<p>A conexão com o banco foi realizada usando a <a href=\"https://github.com/jtv/libpqxx\">libpqxx</a> por meio de Unix Domain Socket,\nque se mostrou mais rápido do que TCP/IP.</p>\n<p>Deixei no projeto duas views que mostram possíveis inconsistências nos dados e em nenhum teste isso aconteceu.</p>\n<div class=\"remark-highlight\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">create</span> <span class=\"token operator\">or</span> <span class=\"token keyword\">replace</span> <span class=\"token keyword\">view</span> account_check\n<span class=\"token keyword\">as</span>\n<span class=\"token keyword\">select</span> a<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span>\n       t<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n    <span class=\"token keyword\">from</span> account a\n    <span class=\"token keyword\">left</span> <span class=\"token keyword\">join</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">select</span> account_id<span class=\"token punctuation\">,</span>\n               <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> trans_balance\n            <span class=\"token keyword\">from</span> <span class=\"token keyword\">transaction</span>\n            <span class=\"token keyword\">group</span> <span class=\"token keyword\">by</span> account_id\n    <span class=\"token punctuation\">)</span> t\n        <span class=\"token keyword\">on</span> t<span class=\"token punctuation\">.</span>account_id <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>id\n    <span class=\"token keyword\">where</span> a<span class=\"token punctuation\">.</span>balance <span class=\"token operator\">&#x3C;</span> a<span class=\"token punctuation\">.</span>overdraft <span class=\"token operator\">or</span>\n          <span class=\"token keyword\">coalesce</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>trans_balance<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&#x3C;></span> a<span class=\"token punctuation\">.</span>balance<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">create</span> <span class=\"token operator\">or</span> <span class=\"token keyword\">replace</span> <span class=\"token keyword\">view</span> transaction_check\n<span class=\"token keyword\">as</span>\n<span class=\"token keyword\">select</span> t<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n    <span class=\"token keyword\">from</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">select</span> id<span class=\"token punctuation\">,</span>\n            account_id<span class=\"token punctuation\">,</span>\n            <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token keyword\">over</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">partition</span> <span class=\"token keyword\">by</span> account_id <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> id<span class=\"token punctuation\">)</span> balance\n            <span class=\"token keyword\">from</span> <span class=\"token keyword\">transaction</span>\n    <span class=\"token punctuation\">)</span> t\n    <span class=\"token keyword\">join</span> account a\n        <span class=\"token keyword\">on</span> a<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> t<span class=\"token punctuation\">.</span>account_id\n    <span class=\"token keyword\">where</span> t<span class=\"token punctuation\">.</span>balance <span class=\"token operator\">&#x3C;</span> a<span class=\"token punctuation\">.</span>overdraft\n    <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> t<span class=\"token punctuation\">.</span>account_id<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<h1>Firebird</h1>\n<p>A versão com o Firebird também ficou com um <strong>p75 de 1ms</strong>, mas pra conseguir isso tive que inovar no modelo de dados,\npois o MVCC do Firebird não se comportou tão bem com múltiplos updates concorrentes nos mesmos registros para atualizar\no saldo. Interessante é que esse problema de performance só aconteceu no notebook. No desktop, mesmo usando um modelo\ntradicional o desempenho foi bom.</p>\n<p>Assim ficou o modelo:</p>\n<div class=\"remark-highlight\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">transaction</span> <span class=\"token punctuation\">(</span>\n    account_id <span class=\"token keyword\">integer</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    seq <span class=\"token keyword\">integer</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    balance <span class=\"token keyword\">integer</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    overdraft <span class=\"token keyword\">integer</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    val <span class=\"token keyword\">integer</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    description <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">datetime</span> <span class=\"token keyword\">timestamp</span> <span class=\"token keyword\">with</span> <span class=\"token keyword\">time</span> zone <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">constraint</span> transaction_pk <span class=\"token keyword\">primary</span> <span class=\"token keyword\">key</span> <span class=\"token punctuation\">(</span>account_id<span class=\"token punctuation\">,</span> seq<span class=\"token punctuation\">)</span> <span class=\"token keyword\">using</span> <span class=\"token keyword\">desc</span> <span class=\"token keyword\">index</span> transaction_pk_desc\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">desc</span> <span class=\"token keyword\">index</span> idx_transaction_account_id_seq_desc <span class=\"token keyword\">on</span> <span class=\"token keyword\">transaction</span> <span class=\"token punctuation\">(</span>\n    account_id<span class=\"token punctuation\">,</span>\n    seq\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>Com uma stored procedure PSQL usando vários recursos interessantes do Firebird, foi possível resolver todos os problemas\nde concorrência dessa forma:</p>\n<div class=\"remark-highlight\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">create</span> <span class=\"token operator\">or</span> <span class=\"token keyword\">alter</span> <span class=\"token keyword\">procedure</span> post_transaction<span class=\"token punctuation\">(</span>\n    account_id <span class=\"token keyword\">integer</span><span class=\"token punctuation\">,</span>\n    val <span class=\"token keyword\">integer</span><span class=\"token punctuation\">,</span>\n    description <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span>\n    status_code <span class=\"token keyword\">integer</span><span class=\"token punctuation\">,</span>\n    balance <span class=\"token keyword\">integer</span><span class=\"token punctuation\">,</span>\n    overdraft <span class=\"token keyword\">integer</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">as</span>\n    <span class=\"token keyword\">declare</span> account_exists <span class=\"token keyword\">boolean</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">begin</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">begin</span>\n        <span class=\"token operator\">in</span> autonomous <span class=\"token keyword\">transaction</span> <span class=\"token keyword\">do</span>\n            <span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> <span class=\"token keyword\">transaction</span> <span class=\"token punctuation\">(</span>account_id<span class=\"token punctuation\">,</span> seq<span class=\"token punctuation\">,</span> balance<span class=\"token punctuation\">,</span> overdraft<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">,</span> description<span class=\"token punctuation\">,</span> <span class=\"token keyword\">datetime</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">select</span> :account_id<span class=\"token punctuation\">,</span>\n                        seq <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n                        new_balance<span class=\"token punctuation\">,</span>\n                        overdraft<span class=\"token punctuation\">,</span>\n                        :val<span class=\"token punctuation\">,</span>\n                        :description<span class=\"token punctuation\">,</span>\n                        <span class=\"token string\">'now'</span>\n                    <span class=\"token keyword\">from</span> <span class=\"token punctuation\">(</span>\n                        <span class=\"token keyword\">select</span> seq<span class=\"token punctuation\">,</span>\n                               balance <span class=\"token operator\">+</span> :val new_balance<span class=\"token punctuation\">,</span>\n                               overdraft\n                            <span class=\"token keyword\">from</span> <span class=\"token keyword\">transaction</span>\n                            <span class=\"token keyword\">where</span> account_id <span class=\"token operator\">=</span> :account_id\n                            <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> seq <span class=\"token keyword\">desc</span>\n                            <span class=\"token keyword\">rows</span> <span class=\"token number\">1</span>\n                    <span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">where</span> new_balance <span class=\"token operator\">>=</span> overdraft\n                <span class=\"token keyword\">returning</span> balance<span class=\"token punctuation\">,</span> overdraft\n                <span class=\"token keyword\">into</span> balance<span class=\"token punctuation\">,</span> overdraft<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>balance <span class=\"token operator\">is</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">then</span>\n            status_code <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>account_exists<span class=\"token punctuation\">)</span> <span class=\"token keyword\">then</span>\n            status_code <span class=\"token operator\">=</span> <span class=\"token number\">422</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">begin</span>\n            status_code <span class=\"token operator\">=</span> <span class=\"token number\">404</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">select</span> <span class=\"token number\">422</span>\n                <span class=\"token keyword\">from</span> <span class=\"token keyword\">transaction</span>\n                <span class=\"token keyword\">where</span> account_id <span class=\"token operator\">=</span> :account_id <span class=\"token operator\">and</span>\n                      seq <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n                <span class=\"token keyword\">into</span> status_code<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">end</span>\n\n        <span class=\"token keyword\">exit</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">when</span> gdscode unique_key_violation <span class=\"token keyword\">do</span>\n        <span class=\"token keyword\">begin</span>\n            account_exists <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n</code></pre></div>\n<p>Como a tabela <code>transaction</code> tem uma primary key em <code>(account_id, seq)</code> e a busca da próxima sequencia é feita\nincrementando o valor da última sequencia (comitada) da conta, quando mais de uma tentativa de inserção de transação\npara uma conta é feita simultaneamente, só a primeira passa e as outras geram um erro de violação de chave primária.</p>\n<p>Quando esse erro acontece, o loop é reiniciado e uma nova transação é iniciada, podendo ler os últimos dados\ncomitados pelas transações concorrentes já finalizadas.</p>\n<p>Usei 0,5 CPU e 390MB para o container do Firebird, 0,2 CPU e 50MB para cada um dos dois containers de API e\n0,6 CPU e 60MB para o haproxy. Idêntico ao projeto com PostgreSQL.</p>\n<p>Mas as similaridades param aí. O Firebird ainda não tem conexão via Unix Domain Socket, então usei TCP/IP com a API OO\nnativa do Firebird.</p>\n<p>Usei 8 workers HTTP em cada container API de forma bastante diferente do que fiz com o projeto do PostgreSQL.\nTodos os threads iniciam conexões de escuta na mesma porta (usando a flag <code>SO_REUSEPORT</code>).\nCada thread possui uma conexão dedicada ao Firebird usando TLS (<code>thread_local</code>).\nDessa forma foi possível usar a mongoose de forma síncrona.</p>\n<p>Deixei no projeto uma view que mostra possíveis inconsistências nos dados e em nenhum teste isso aconteceu.</p>\n<div class=\"remark-highlight\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">create</span> <span class=\"token operator\">or</span> <span class=\"token keyword\">alter</span> <span class=\"token keyword\">view</span> transaction_check\n<span class=\"token keyword\">as</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span>\n    <span class=\"token keyword\">from</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">select</span> t<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span>\n               <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token keyword\">over</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">partition</span> <span class=\"token keyword\">by</span> account_id <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> seq<span class=\"token punctuation\">)</span> calc_balance\n            <span class=\"token keyword\">from</span> <span class=\"token keyword\">transaction</span> t\n    <span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">where</span> balance <span class=\"token operator\">&#x3C;</span> overdraft <span class=\"token operator\">or</span>\n          calc_balance <span class=\"token operator\">&#x3C;></span> balance\n    <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> account_id<span class=\"token punctuation\">,</span> seq<span class=\"token punctuation\">;</span>\n</code></pre></div>\n<h1>LMDB</h1>\n<p>Queria fazer uma versão com um banco de dados chave/valor que conseguisse compartilhar o banco de dados em diferentes\nprocessos sem necessidade de usar um container específico. Descobri o LMDB, ou Lightning Memory-Mapped Database.</p>\n<p>O LMDB mapeia um arquivo de disco em memória (<code>mmap</code>) e pode ser usado simultaneamente por diferentes processos.</p>\n<p>A versão com o LMDB ficou com um <strong>p75 de 0ms</strong>.</p>\n<p>Defini o modelo com uma chave com o código da conta e os dados como abaixo:</p>\n<div class=\"remark-highlight\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token keyword\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>packed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">TransactionData</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">uint8_t</span> reverseSeq<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">int64_t</span> dateTime<span class=\"token punctuation\">;</span>\n\tstd<span class=\"token operator\">::</span>array<span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token operator\">></span> description<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> balance<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> overdraft<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>Precisei adicionar uma chave <code>reverseSeq</code> que é uma auto-decrement para os registros ficarem ordenados iniciando pelos\núltimos inseridos. Apesar do LMDB ser transacional, para gerar essa chave de forma única, criei um mutex compartilhado\n(<code>boost::interprocess::named_mutex</code>) entre os dois containers de API. Pra isso foi necessário colocá-los no mesmo\n<code>pid namespace</code> do docker.</p>\n<p>Usei 0,4 CPU e 150MB para cada um dos dois containers de API e 0,7 CPU e 150MB para o haproxy.\nA mongoose foi usada como no Firebird, com <code>SO_REUSEPORT</code>. O LMDB permite (e requer) que apenas uma conexão seja feita\npara cada banco de dados em um mesmo processo.</p>\n<h1>Uma técnica interessante</h1>\n<p>Cheguei a testar uma técnica interessante que mostrou ter um desempenho muito bom, mas com alguns picos que\natrapalhavam. Não debuguei o problema e não coloquei em nenhum dos projetos.</p>\n<p>A técnica foi criar um load balancer próprio com a mongoose e repassar os sockets abertos para as APIs responderem\ndiretamente aos clientes, sem rotear as respostas usando o load balancer. Essa técnica é chamada socket takeover e\nfoi detalhada\n<a href=\"https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec\">aqui</a>,\nembora com motivação diferente.</p>\n<h1>A ideia inicial</h1>\n<p>Inicialmente minha ideia era desenvolver a API usando GRPC e colocar o <a href=\"https://www.envoyproxy.io/\">envoy</a> como\nload balancer fazendo a conversão de HTTP para GRPC. Isso até foi possível usando\n<a href=\"https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter\">esse filtro</a>,\ncom algumas dificuldades de conversão de respostas GRPC para status code HTTP nos casos de erros, onde foi necessário\nusar scrips LUA. Porém o desempenho não foi bom.</p>\n<h1>Curiosidades</h1>\n<ul>\n<li>A mongoose não suporta o uso de <code>SO_REUSEPORT</code> mas se tiver um <code>#define</code> com o nome <code>SO_EXCLUSIVEADDRUSE</code> ela\nseta essa flag nos sockets. Como esse define não existe no Linux, criei um <code>triplet vcpkg</code> e um <code>toolchain cmake</code>\npara passar <code>SO_REUSEPORT</code> no lugar:</li>\n</ul>\n<div class=\"remark-highlight\"><pre class=\"language-cmake\"><code class=\"language-cmake\"><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token variable\">CMAKE_C_FLAGS</span> <span class=\"token string\">\"-DSO_EXCLUSIVEADDRUSE=SO_REUSEPORT\"</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<ul>\n<li>\n<p>Usei o <code>haproxy</code> no modo <code>tcp</code> para ter o mínimo overhead possível</p>\n</li>\n<li>\n<p>Usei o gerenciador de memória <a href=\"https://github.com/microsoft/mimalloc\">mimalloc</a> da Microsoft para economizar\nalguns ciclos de CPU</p>\n</li>\n<li>\n<p>A função <code>mg_match</code> da mongoose foi mais rápida do que deixar uma regex C++ pré-compilada</p>\n</li>\n<li>\n<p><code>std::format_to_n</code> foi mais rápida que <code>sprintf</code></p>\n</li>\n<li>\n<p><code>g++</code> (com <code>libstdc++</code>) foi mais rapido que <code>clang++</code> com <code>libstdc++</code> e <code>libc++</code></p>\n</li>\n<li>\n<p>Usando a experiência que adquiriram na rinha de 2023, usei <code>network_mode: host</code> em todos os containers, embora na\nminhas máquinas não tenha tido vantagens</p>\n</li>\n</ul>\n","layout":"post","title":"Rinha de Backend - 2024/Q1","published":true,"date":"2024-03-10","author":"Adriano dos Santos Fernandes","tags":["c++","docker","firebird","postgresql","web"]}},"__N_SSG":true}